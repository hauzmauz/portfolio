<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Espen Moe - Welcome</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Work+Sans:wght@200;300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Work Sans', sans-serif;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.8s ease;
        }

        body.loaded {
            opacity: 1;
        }

        body.unloading {
            opacity: 0;
        }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #d6d6d6;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.8s ease;
        }

        .loading-overlay.hide {
            opacity: 0;
            pointer-events: none;
        }

        .loader-animation {
            width: 64px;
            height: 64px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            filter: brightness(0) saturate(100%) invert(40%) sepia(0%) saturate(0%) hue-rotate(0deg) brightness(60%) contrast(100%);
            opacity: 0.8;
        }

        @media (max-width: 600px) {
            .loader-animation {
                width: 48px;
                height: 48px;
            }
        }

        #canvas {
            display: block;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 1001;
            width: 250px;
            display: none;
            transition: all 0.3s ease;
        }

        .controls.open {
            display: block;
        }

        .controls.open ~ .settings-toggle {
            background-color: transparent;
            box-shadow: none;
        }

        .settings-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 30px;
            height: 30px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 3px;
            cursor: pointer;
            z-index: 1003;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            background-image: url('portfolio/images/icon-experimental.png');
            background-size: 18px 18px;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.6;
            transition: opacity 0.2s ease;
        }

        .settings-toggle:hover {
            opacity: 1;
        }

        .disclaimer-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 420px;
            background: rgba(255, 255, 255, 0.0);
            backdrop-filter: blur(30px);
            border-radius: 15px;
            z-index: 1000;
            padding: 20px 25px 20px 20px;
            box-sizing: border-box;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: 0 8px 48px rgba(0, 0, 0, 0.1);
        }

        .enter-button {
            background: transparent;
            border: none;
            border-radius: 8px;
            padding: 8px 30px;
            font-family: 'Work Sans', sans-serif;
            font-weight: 400;
            color: #333;
            cursor: pointer;
            pointer-events: auto;
            display: flex;
            align-items: center;
            text-decoration: none;
            font-size: 16px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            transition: all 1s ease;
            line-height: 1;
        }

        .enter-button:hover {
            background: transparent;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.2);
        }

        .enter-icon {
            width: 20px;
            height: 16px;
            background-image: url('portfolio/images/icon-enter.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        @media (max-width: 600px) {
            .disclaimer-box {
                width: 85vw;
                max-width: 350px;
                padding: 15px;
            }
            
            .enter-button {
                font-size: 14px !important;
                padding: 6px 20px !important;
            }
        }

        .text-link {
            color: #333333;
            text-decoration: none;
            pointer-events: auto;
        }

        .text-link:hover {
            color: #333333;
        }

        .arrow-icon {
            display: inline-block;
            width: 1.8em;
            height: 1.8em;
            background-image: url('portfolio/images/arrow-right.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            margin-left: -24px;
            vertical-align: middle;
            opacity: 0.8;
            transform: translateY(-1px);
            filter: brightness(0) saturate(100%) invert(100%) sepia(0%) saturate(0%) hue-rotate(0deg) brightness(100%) contrast(100%);
        }
        .arrow-icon:first-of-type {
            margin-left: -2px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 5px;
        }

        .control-row input[type="range"] {
            flex: 1;
        }

        .control-row input[type="number"] {
            width: 60px;
            padding: 3px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 11px;
        }

        .control-row input[type="text"] {
            width: 70px;
            padding: 3px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-family: monospace;
            font-size: 14px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 123, 255, 0.3);
        }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .value-display {
            font-size: 12px;
            color: #666;
            text-align: right;
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loader-animation" id="loaderAnimation"></div>
    </div>

    <div class="controls" id="controls">
        <div style="margin: 0 0 20px 0; text-align: left; color: #333; font-size: 16px; font-weight: 600; letter-spacing: 1px;">HAVE FUN!</div>
        
        <div class="control-group">
            <label for="dotCount">Dot Count</label>
            <div class="control-row">
                <input type="range" id="dotCount" min="100" max="2500" value="1000" step="10">
                <input type="number" id="dotCountInput" value="1000" min="1" style="width: 60px; padding: 3px; border: 1px solid #ddd; border-radius: 3px;">
            </div>
        </div>
        
        <div class="control-group">
            <label for="dotSize">Dot Size</label>
            <div class="control-row">
                <input type="range" id="dotSize" min="0.5" max="10" value="2.5" step="0.5">
                <input type="number" id="dotSizeInput" value="2.5" min="0.1" step="0.1" style="width: 60px; padding: 3px; border: 1px solid #ddd; border-radius: 3px;">
            </div>
        </div>
        
        <div class="control-group">
            <label for="scaleMultiplier">Scale</label>
            <div class="control-row">
                <input type="range" id="scaleMultiplier" min="10" max="150" value="20" step="5">
                <input type="number" id="scaleMultiplierInput" value="20" min="0.1" step="0.1" style="width: 60px; padding: 3px; border: 1px solid #ddd; border-radius: 3px;">
            </div>
        </div>
        
        <div class="control-group">
            <label for="mouseInfluence">Cursor Size</label>
            <div class="control-row">
                <input type="range" id="mouseInfluence" min="50" max="600" value="180" step="10">
                <input type="number" id="mouseInfluenceInput" value="180" min="1" style="width: 60px; padding: 3px; border: 1px solid #ddd; border-radius: 3px;">
            </div>
        </div>
        
        <div class="control-group">
            <label for="animationSpeed">Animation Speed</label>
            <div class="control-row">
                <input type="range" id="animationSpeed" min="50" max="750" value="10" step="25">
                <input type="number" id="animationSpeedInput" value="10" min="1" style="width: 60px; padding: 3px; border: 1px solid #ddd; border-radius: 3px;">
            </div>
        </div>
        
        <div class="control-group">
            <label for="easeAmount">Ease Amount</label>
            <div class="control-row">
                <input type="range" id="easeAmount" min="0.005" max="0.095" value="0.095" step="0.005">
                <input type="number" id="easeAmountInput" value="0.095" min="0.001" step="0.001" style="width: 60px; padding: 3px; border: 1px solid #ddd; border-radius: 3px;">
            </div>
        </div>
        
        <div class="control-group">
            <label for="minDistance">Min Distance Buffer</label>
            <div class="control-row">
                <input type="range" id="minDistance" min="5" max="60" value="20" step="1">
                <input type="number" id="minDistanceInput" value="20" min="0" style="width: 60px; padding: 3px; border: 1px solid #ddd; border-radius: 3px;">
            </div>
        </div>
        
        <div class="control-group">
            <label for="fadeZone">Edge Fade Zone</label>
            <div class="control-row">
                <input type="range" id="fadeZone" min="0" max="100" value="0" step="5">
                <input type="number" id="fadeZoneInput" value="0" min="0" style="width: 60px; padding: 3px; border: 1px solid #ddd; border-radius: 3px;">
            </div>
        </div>
        
        <div class="control-group">
            <label for="densityScaling">Density Scaling</label>
            <div class="control-row">
                <input type="range" id="densityScaling" min="0" max="2" value="0.9" step="0.1">
                <input type="number" id="densityScalingInput" value="0.9" min="0.1" step="0.1" style="width: 60px; padding: 3px; border: 1px solid #ddd; border-radius: 3px;">
            </div>
        </div>
        
        <div class="control-group">
            <label for="stabilityMode">Stability Mode</label>
            <input type="checkbox" id="stabilityMode" checked style="margin-top: 5px;">
            <label for="stabilityMode" style="display: inline; margin-left: 5px; font-size: 11px; text-transform: none;">intelligent calming</label>
        </div>
        
        <div class="control-group">
            <label for="maxVelocity">Max Velocity</label>
            <div class="control-row">
                <input type="range" id="maxVelocity" min="50" max="350" value="50" step="10">
                <input type="number" id="maxVelocityInput" value="50" min="0.1" step="0.1" style="width: 60px; padding: 3px; border: 1px solid #ddd; border-radius: 3px;">
            </div>
        </div>
        
        <div class="control-group">
            <label for="densityDamping">Density Damping</label>
            <input type="checkbox" id="densityDamping" style="margin-top: 5px;">
            <label for="densityDamping" style="display: inline; margin-left: 5px; font-size: 11px; text-transform: none;">More damping</label>
        </div>
        
        <div class="control-group">
            <label for="dotColor">Dot Color</label>
            <div class="control-row">
                <input type="color" id="dotColor" value="#e0e0e0">
                <input type="text" id="dotColorHex" value="#e0e0e0" maxlength="7" style="width: 70px; padding: 3px; border: 1px solid #ddd; border-radius: 3px; font-family: monospace;">
            </div>
        </div>
        
        <div class="control-group">
            <label for="bgColor">Background Color</label>
            <div class="control-row">
                <input type="color" id="bgColor" value="#d6d6d6">
                <input type="text" id="bgColorHex" value="#d6d6d6" maxlength="7" style="width: 70px; padding: 3px; border: 1px solid #ddd; border-radius: 3px; font-family: monospace;">
            </div>
        </div>
    </div>

    <div class="settings-toggle" id="settingsToggle"></div>

    <canvas id="canvas"></canvas>

    <div class="disclaimer-box">
        <div style="display: flex; gap: 13px; align-items: center;">
            <div style="width: 40px; height: 40px; background-image: url('portfolio/images/icon-experimental.png'); background-size: contain; background-repeat: no-repeat; background-position: center; flex-shrink: 0; opacity: 0.8;"></div>
            <div style="flex: 1;">
                    <div style="margin: 0; font-size: 18px; line-height: 1.3; color: #666; font-family: 'Work Sans', sans-serif; padding-bottom:5px;"><b>Welcome</b></div><div style="margin: 0; font-size: 16px; line-height: 1.3; color: #666; font-family: 'Work Sans', sans-serif;">This site is under development, so content is limited and functionality will change.
            </div>
            </div>
        </div>
        <div style="display: flex; justify-content: flex-end; padding-top: 0px;">
            <a href="portfolio/index.html" class="enter-button">
                Enter
            </a>
        </div>
    </div>

    <script>
        class StippleSystem {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.dots = [];
                this.mouse = { x: -1000, y: -1000 };
                
                // Core Settings - easily modifiable
                this.settings = {
                    // Dot properties
                    dotCount: 1000,
                    dotSize: 2.5,
                    dotColor: '#e0e0e0',
                    bgColor: '#d6d6d6',
                    
                    // Animation properties
                    easeAmount: 0.095,
                    dampingFactor: 0.95,
                    animationSpeed: 10.0,
                    
                    // Mouse interaction
                    mouseInfluence: 180,
                    mouseSizeMultiplier: 5.0,
                    scaleMultiplier: 20,
                    
                    // Stipple distribution
                    idealSpacing: 80,
                    spacingTolerance: 0.3,
                    distributionForce: 0.8,
                    
                    // Displacement behavior
                    displacementStrength: 0.2,
                    returnForce: 0.02,
                    
                    // Scaling behavior
                    minDistanceBuffer: 20,
                    
                    // Edge effects
                    fadeZone: 0,
                    
                    // Density scaling
                    densityScaling: 0.9,
                    
                    // Stability controls
                    stabilityMode: true,
                    maxVelocity: 50,
                    restThreshold: 0.1,
                    densityDamping: false
                };

                // Start intelligent loading sequence
                this.initializeWithIntelligentLoading();
            }

            async initializeWithIntelligentLoading() {
                // Start loader animation
                this.startLoaderAnimation();
                
                // Wait for all assets to be ready
                await this.waitForAssetsReady();
                
                // Initialize the system
                this.setupCanvas();
                this.generateStippleGrid();
                this.setupControls();
                this.setupEventListeners();
                this.setupSettingsToggle();
                this.initCogsAnimation();
                this.adaptColorsToBackground();
                
                // Hide loader and start animation
                this.hideLoader();
                this.animate();
            }

            startLoaderAnimation() {
                const loaderElement = document.getElementById('loaderAnimation');
                let currentFrame = 0;
                const totalFrames = 19; // loader00.png to loader18.png
                
                // Clear any existing loader interval
                if (window.loaderAnimationInterval) {
                    clearInterval(window.loaderAnimationInterval);
                }
                
                function updateLoaderFrame() {
                    if (loaderElement) {
                        loaderElement.style.backgroundImage = `url('images/loader/loader${String(currentFrame).padStart(2, '0')}.png')`;
                    }
                    currentFrame = (currentFrame + 1) % totalFrames;
                }
                
                // Set initial frame and start animation
                updateLoaderFrame();
                window.loaderAnimationInterval = setInterval(updateLoaderFrame, 80); // ~12fps for smooth loading animation
            }

            async waitForAssetsReady() {
                const promises = [];
                
                // Wait for fonts to load
                if (document.fonts && document.fonts.ready) {
                    promises.push(document.fonts.ready);
                }
                
                // Wait for cogs animation frames to preload
                const cogsFramePromises = [];
                for (let i = 0; i < 12; i++) {
                    const img = new Image();
                    const framePromise = new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = resolve; // Don't fail if some frames don't load
                        setTimeout(resolve, 1000); // Timeout after 1 second
                    });
                    img.src = `portfolio/images/cogs/Cogs-48px_${String(i).padStart(5, '0')}.png`;
                    cogsFramePromises.push(framePromise);
                }
                promises.push(...cogsFramePromises);
                
                // Wait for loader frames to preload (at least first few)
                const loaderFramePromises = [];
                for (let i = 0; i < Math.min(5, 19); i++) { // Preload first 5 frames for smooth start
                    const img = new Image();
                    const framePromise = new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = resolve; // Don't fail if some frames don't load
                        setTimeout(resolve, 500); // Shorter timeout for loader
                    });
                    img.src = `images/loader/loader${String(i).padStart(2, '0')}.png`;
                    loaderFramePromises.push(framePromise);
                }
                promises.push(...loaderFramePromises);
                
                // Wait for all promises to resolve
                await Promise.all(promises);
                
                // Add a small delay to ensure everything is settled
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            hideLoader() {
                const loadingOverlay = document.getElementById('loadingOverlay');
                if (loadingOverlay) {
                    loadingOverlay.classList.add('hide');
                    
                    // NOW fade in the page content AFTER loading is complete
                    document.body.classList.add('loaded');
                    
                    // Clean up loader animation interval
                    if (window.loaderAnimationInterval) {
                        clearInterval(window.loaderAnimationInterval);
                        window.loaderAnimationInterval = null;
                    }
                    
                    // Remove overlay after transition
                    setTimeout(() => {
                        if (loadingOverlay.parentNode) {
                            loadingOverlay.parentNode.removeChild(loadingOverlay);
                        }
                    }, 800);
                }
            }

            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                    this.generateStippleGrid();
                });
            }

            resizeCanvas() {
                // Extend canvas slightly beyond viewport to allow dots to move off-screen
                const extension = 50;
                this.canvas.width = window.innerWidth + (extension * 2);
                this.canvas.height = window.innerHeight + (extension * 2);
                
                // Position canvas to center the extended area
                this.canvas.style.position = 'fixed';
                this.canvas.style.left = `-${extension}px`;
                this.canvas.style.top = `-${extension}px`;
            }

            // Generate evenly distributed stipple pattern
            generateStippleGrid() {
                // Use viewport size for dot generation, not extended canvas size
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const extension = 50; // Match the extension from resizeCanvas
                
                // Calculate actual dot count based on viewport size
                // Base calculation on a reference size (e.g., 1920x1080)
                const referenceArea = 1920 * 1080;
                const currentArea = viewportWidth * viewportHeight;
                const areaRatio = currentArea / referenceArea;
                
                // Scale dot count by area ratio, but with some limits
                const minRatio = 0.3; // Never go below 30% of dots
                const maxRatio = 2.0;  // Never go above 200% of dots
                const scaledRatio = Math.max(minRatio, Math.min(maxRatio, areaRatio));
                
                // Apply user-controlled density scaling
                const finalRatio = scaledRatio * this.settings.densityScaling;
                const actualDotCount = Math.round(this.settings.dotCount * finalRatio);
                
                console.log('Generating dots. Base count:', this.settings.dotCount, 'Scaled count:', actualDotCount, 'Area ratio:', areaRatio.toFixed(2), 'Viewport:', viewportWidth + 'x' + viewportHeight);
                this.dots = [];
                
                // Create a more even distribution using grid with randomness
                const cols = Math.ceil(Math.sqrt(actualDotCount * (viewportWidth / viewportHeight)));
                const rows = Math.ceil(actualDotCount / cols);
                const cellWidth = viewportWidth / cols;
                const cellHeight = viewportHeight / rows;
                
                for (let i = 0; i < actualDotCount; i++) {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    
                    // Place in grid cell with random offset, then offset by extension
                    const x = (col + 0.2 + Math.random() * 0.6) * cellWidth + extension;
                    const y = (row + 0.2 + Math.random() * 0.6) * cellHeight + extension;
                    
                    this.dots.push({
                        // Current position
                        x: x,
                        y: y,
                        
                        // Velocity
                        vx: 0,
                        vy: 0,
                        
                        // Size properties
                        size: this.settings.dotSize,
                        targetSize: this.settings.dotSize,
                        
                        // State
                        isDisplaced: false
                    });
                }
                
                console.log('Generated', this.dots.length, 'dots');
            }

            // Calculate mouse influence on dot size with smooth falloff
            calculateMouseInfluence(dot) {
                const dx = dot.x - this.mouse.x;
                const dy = dot.y - this.mouse.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < this.settings.mouseInfluence) {
                    // Smooth falloff using easing curves
                    const normalizedDistance = distance / this.settings.mouseInfluence;
                    
                    // Multiple falloff options - using smooth cubic easing
                    const influence = 1 - Math.pow(normalizedDistance, 3); // Cubic falloff for very smooth transition
                    
                    // Alternative falloffs you could try:
                    // const influence = 1 - Math.pow(normalizedDistance, 2); // Quadratic falloff
                    // const influence = Math.cos(normalizedDistance * Math.PI / 2); // Cosine falloff
                    // const influence = 1 - normalizedDistance * normalizedDistance * (3 - 2 * normalizedDistance); // Smoothstep
                    
                    dot.targetSize = this.settings.dotSize * (1 + influence * this.settings.scaleMultiplier);
                    return influence;
                } else {
                    dot.targetSize = this.settings.dotSize;
                    return 0;
                }
            }

            // AGGRESSIVE anti-overlap system - NEVER allow overlapping
            calculateDisplacementForces(dot, index) {
                let fx = 0, fy = 0;
                
                this.dots.forEach((other, i) => {
                    if (i === index) return;
                    
                    const dx = dot.x - other.x;
                    const dy = dot.y - other.y;
                    const centerDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (centerDistance > 0) {
                        // STRICT minimum distance - edge to edge + adjustable buffer
                        const requiredDistance = dot.size + other.size + this.settings.minDistanceBuffer;
                        
                        if (centerDistance < requiredDistance) {
                            // IMMEDIATE and STRONG separation force
                            const overlap = requiredDistance - centerDistance;
                            const urgency = Math.min(overlap / requiredDistance, 1); // 0-1 urgency
                            
                            // Gentle force - much more subtle movement
                            const baseForce = Math.pow(urgency, 2) * 2; // Reduced base force
                            const emergencyMultiplier = overlap < 5 ? 5 : 1; // Reduced emergency mode
                            
                            const totalForce = baseForce * emergencyMultiplier * this.settings.displacementStrength;
                            
                            fx += (dx / centerDistance) * totalForce;
                            fy += (dy / centerDistance) * totalForce;
                        }
                        // Stronger spacing force for faster distribution
                        else if (centerDistance < this.settings.idealSpacing) {
                            const spacingGap = this.settings.idealSpacing - centerDistance;
                            const spacingForce = (spacingGap / this.settings.idealSpacing) * 0.5; // Increased from 0.1 to 0.5
                            
                            fx += (dx / centerDistance) * spacingForce;
                            fy += (dy / centerDistance) * spacingForce;
                        }
                    }
                });
                
                return { fx, fy };
            }

            // Calculate return force to original position
            calculateReturnForce(dot) {
                const dx = dot.originalX - dot.x;
                const dy = dot.originalY - dot.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    const returnStrength = this.settings.returnForce * Math.min(distance / this.settings.idealSpacing, 1);
                    return {
                        fx: (dx / distance) * returnStrength,
                        fy: (dy / distance) * returnStrength
                    };
                }
                
                return { fx: 0, fy: 0 };
            }

            updateDots() {
                // Debug: Check if dots exist before update
                if (this.dots.length === 0) {
                    console.log('No dots to update!');
                    return;
                }
                
                this.dots.forEach((dot, i) => {
                    // Skip update if dot is invalid
                    if (!dot || typeof dot.x !== 'number' || typeof dot.y !== 'number') {
                        console.log('Invalid dot found:', dot);
                        return;
                    }
                    
                    // 1. Calculate mouse influence on size
                    const mouseInfluence = this.calculateMouseInfluence(dot);
                    
                    // 2. Calculate displacement forces from enlarged neighbors
                    const displacement = this.calculateDisplacementForces(dot, i);
                    
                    // 3. Only use displacement forces (no return force)
                    let totalFx = displacement.fx;
                    let totalFy = displacement.fy;
                    
                    // 5. Apply forces with easing and speed multiplier (limit extreme values)
                    const forceX = totalFx * this.settings.easeAmount * this.settings.animationSpeed;
                    const forceY = totalFy * this.settings.easeAmount * this.settings.animationSpeed;
                    
                    // Allow higher forces for spacing but limit extreme values
                    const maxForce = 5; // Increased to allow faster spacing distribution
                    dot.vx += Math.max(-maxForce, Math.min(maxForce, forceX));
                    dot.vy += Math.max(-maxForce, Math.min(maxForce, forceY));
                    
                    // 6. Apply intelligent damping system
                    let dampingFactor = this.settings.dampingFactor;
                    
                    // STABILITY MODE: Adaptive damping based on density and movement
                    if (this.settings.stabilityMode) {
                        // Calculate local density around this dot
                        let nearbyDots = 0;
                        const checkRadius = 100;
                        this.dots.forEach((other, j) => {
                            if (j !== i) {
                                const dx = dot.x - other.x;
                                const dy = dot.y - other.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                if (distance < checkRadius) nearbyDots++;
                            }
                        });
                        
                        // More damping in dense areas
                        const densityFactor = Math.min(nearbyDots / 10, 1); // 0-1 based on nearby dots
                        const densityDamping = this.settings.densityDamping ? (0.85 - densityFactor * 0.15) : 1;
                        dampingFactor *= densityDamping;
                        
                        // Velocity-based damping - faster dots get more damping
                        const velocity = Math.sqrt(dot.vx * dot.vx + dot.vy * dot.vy);
                        if (velocity > this.settings.restThreshold) {
                            const velocityDamping = Math.max(0.8, 1 - (velocity / 10));
                            dampingFactor *= velocityDamping;
                        }
                    }
                    
                    // Increase damping near edges to prevent pong effect
                    const edgeProximity = Math.min(
                        dot.x / this.canvas.width,
                        (this.canvas.width - dot.x) / this.canvas.width,
                        dot.y / this.canvas.height,
                        (this.canvas.height - dot.y) / this.canvas.height
                    );
                    
                    if (edgeProximity < 0.1) { // Within 10% of edge
                        dampingFactor = Math.max(0.8, dampingFactor - 0.1); // Extra damping
                    }
                    
                    dot.vx *= dampingFactor;
                    dot.vy *= dampingFactor;
                    
                    // STABILITY MODE: Velocity limiting
                    if (this.settings.stabilityMode) {
                        const velocity = Math.sqrt(dot.vx * dot.vx + dot.vy * dot.vy);
                        if (velocity > this.settings.maxVelocity) {
                            const scale = this.settings.maxVelocity / velocity;
                            dot.vx *= scale;
                            dot.vy *= scale;
                        }
                    }
                    
                    // 7. Update position
                    dot.x += dot.vx;
                    dot.y += dot.vy;
                    
                    // Gentle boundary system - soft preference to stay on screen but allow movement beyond
                    const margin = 100; // Larger margin for gentler effect
                    const edgeForce = 0.1; // Much weaker force
                    const extension = 50; // Canvas extension
                    
                    // Use viewport boundaries, not canvas boundaries
                    const leftBound = extension;
                    const rightBound = window.innerWidth + extension;
                    const topBound = extension;
                    const bottomBound = window.innerHeight + extension;
                    
                    // Only apply gentle forces, no hard boundaries
                    // Left edge
                    if (dot.x < leftBound + margin) {
                        const pushForce = ((leftBound + margin) - dot.x) / margin * edgeForce;
                        dot.vx += pushForce;
                    }
                    // Right edge  
                    if (dot.x > rightBound - margin) {
                        const pushForce = (dot.x - (rightBound - margin)) / margin * edgeForce;
                        dot.vx -= pushForce;
                    }
                    // Top edge
                    if (dot.y < topBound + margin) {
                        const pushForce = ((topBound + margin) - dot.y) / margin * edgeForce;
                        dot.vy += pushForce;
                    }
                    // Bottom edge
                    if (dot.y > bottomBound - margin) {
                        const pushForce = (dot.y - (bottomBound - margin)) / margin * edgeForce;
                        dot.vy -= pushForce;
                    }
                    
                    // EMERGENCY OVERLAP CORRECTION - Direct position adjustment
                    this.dots.forEach((other, j) => {
                        if (j <= i) return; // Only check each pair once
                        
                        const dx = dot.x - other.x;
                        const dy = dot.y - other.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minDistance = dot.size + other.size + this.settings.minDistanceBuffer;
                        
                        if (distance < minDistance && distance > 0) {
                            // DIRECT position correction - move both dots apart
                            const correction = (minDistance - distance) / 2;
                            const moveX = (dx / distance) * correction;
                            const moveY = (dy / distance) * correction;
                            
                            dot.x += moveX;
                            dot.y += moveY;
                            other.x -= moveX;
                            other.y -= moveY;
                        }
                    });
                    
                    // 8. Smooth size transition with asymmetric scaling
                    const sizeDifference = dot.targetSize - dot.size;
                    let scalingSpeed;
                    
                    if (sizeDifference > 0) {
                        // Scaling up - fast (as before)
                        scalingSpeed = 0.15;
                    } else {
                        // Scaling down - much slower (3-4x slower)
                        scalingSpeed = 0.04;
                    }
                    
                    dot.size += sizeDifference * scalingSpeed;
                });
            }

            // HSB to RGB conversion
            hsbToRgb(h, s, b) {
                s /= 100;
                b /= 100;
                const c = b * s;
                const x = c * (1 - Math.abs((h / 60) % 2 - 1));
                const m = b - c;
                let r, g, bl;
                
                if (h >= 0 && h < 60) {
                    r = c; g = x; bl = 0;
                } else if (h >= 60 && h < 120) {
                    r = x; g = c; bl = 0;
                } else if (h >= 120 && h < 180) {
                    r = 0; g = c; bl = x;
                } else if (h >= 180 && h < 240) {
                    r = 0; g = x; bl = c;
                } else if (h >= 240 && h < 300) {
                    r = x; g = 0; bl = c;
                } else {
                    r = c; g = 0; bl = x;
                }
                
                r = Math.round((r + m) * 255);
                g = Math.round((g + m) * 255);
                bl = Math.round((bl + m) * 255);
                
                return { r, g, b: bl };
            }
            
            // RGB to Hex conversion
            rgbToHex(r, g, b) {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }
            
            // Update color from HSB sliders
            updateColorFromHSB(type) {
                const h = parseInt(document.getElementById(`${type}Hue`).value);
                const s = parseInt(document.getElementById(`${type}Sat`).value);
                const b = parseInt(document.getElementById(`${type}Bright`).value);
                
                const rgb = this.hsbToRgb(h, s, b);
                const hex = this.rgbToHex(rgb.r, rgb.g, rgb.b);
                
                document.getElementById(`${type}ColorHex`).value = hex;
                
                if (type === 'dot') {
                    this.settings.dotColor = hex;
                } else {
                    this.settings.bgColor = hex;
                }
            }

            setupControls() {
                // Helper function to sync slider and input
                const syncControls = (sliderId, inputId, settingKey, callback) => {
                    const slider = document.getElementById(sliderId);
                    const input = document.getElementById(inputId);
                    
                    if (slider && input) {
                        // Slider changes input
                        slider.addEventListener('input', (e) => {
                            const value = e.target.value;
                            input.value = value;
                            this.settings[settingKey] = parseFloat(value);
                            if (callback) callback();
                        });
                        
                        // Input changes slider (if within range) and setting
                        input.addEventListener('input', (e) => {
                            const value = parseFloat(e.target.value);
                            if (!isNaN(value)) {
                                this.settings[settingKey] = value;
                                // Update slider if value is within range
                                if (value >= parseFloat(slider.min) && value <= parseFloat(slider.max)) {
                                    slider.value = value;
                                }
                                if (callback) callback();
                            }
                        });
                    }
                };

                // Setup all controls with sync
                syncControls('dotCount', 'dotCountInput', 'dotCount', () => this.generateStippleGrid());
                syncControls('dotSize', 'dotSizeInput', 'dotSize', () => {
                    this.dots.forEach(dot => {
                        if (dot.targetSize === dot.size) {
                            dot.targetSize = this.settings.dotSize;
                        }
                    });
                });
                syncControls('scaleMultiplier', 'scaleMultiplierInput', 'scaleMultiplier');
                syncControls('mouseInfluence', 'mouseInfluenceInput', 'mouseInfluence');
                syncControls('animationSpeed', 'animationSpeedInput', 'animationSpeed');
                syncControls('easeAmount', 'easeAmountInput', 'easeAmount');
                syncControls('minDistance', 'minDistanceInput', 'minDistanceBuffer');
                syncControls('fadeZone', 'fadeZoneInput', 'fadeZone');
                syncControls('densityScaling', 'densityScalingInput', 'densityScaling', () => this.generateStippleGrid());
                syncControls('maxVelocity', 'maxVelocityInput', 'maxVelocity');

                // Checkbox controls for stability features
                const stabilityMode = document.getElementById('stabilityMode');
                const densityDamping = document.getElementById('densityDamping');
                
                if (stabilityMode) {
                    stabilityMode.addEventListener('change', (e) => {
                        this.settings.stabilityMode = e.target.checked;
                    });
                }
                
                if (densityDamping) {
                    densityDamping.addEventListener('change', (e) => {
                        this.settings.densityDamping = e.target.checked;
                    });
                }

                // Color controls (existing functionality)
                const dotColor = document.getElementById('dotColor');
                const bgColor = document.getElementById('bgColor');
                
                if (dotColor) {
                    dotColor.addEventListener('input', (e) => {
                        this.settings.dotColor = e.target.value;
                        document.getElementById('dotColorHex').value = e.target.value;
                    });
                }
                
                if (bgColor) {
                    bgColor.addEventListener('input', (e) => {
                        this.settings.bgColor = e.target.value;
                        document.getElementById('bgColorHex').value = e.target.value;
                    });
                }

                // HSB slider event listeners
                ['dotHue', 'dotSat', 'dotBright'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', (e) => {
                            document.getElementById(id + 'Value').textContent = e.target.value;
                            this.updateColorFromHSB('dot');
                        });
                    }
                });

                ['bgHue', 'bgSat', 'bgBright'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', (e) => {
                            document.getElementById(id + 'Value').textContent = e.target.value;
                            this.updateColorFromHSB('bg');
                        });
                    }
                });

                // Add hex input functionality
                const dotColorHex = document.getElementById('dotColorHex');
                const bgColorHex = document.getElementById('bgColorHex');
                const dotColorPicker = document.getElementById('dotColor');
                const bgColorPicker = document.getElementById('bgColor');

                if (dotColorHex && dotColorPicker) {
                    dotColorHex.addEventListener('input', (e) => {
                        const value = e.target.value;
                        if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
                            this.settings.dotColor = value;
                            dotColorPicker.value = value;
                        }
                    });
                }

                if (bgColorHex && bgColorPicker) {
                    bgColorHex.addEventListener('input', (e) => {
                        const value = e.target.value;
                        if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
                            this.settings.bgColor = value;
                            bgColorPicker.value = value;
                        }
                    });
                }
            }

            setupEventListeners() {
                // Mouse events for desktop
                this.canvas.addEventListener('mousemove', (e) => {
                    this.mouse.x = e.clientX;
                    this.mouse.y = e.clientY;
                });

                this.canvas.addEventListener('mouseleave', () => {
                    this.mouse.x = -1000;
                    this.mouse.y = -1000;
                });

                // Touch events for mobile
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (e.touches.length > 0) {
                        this.mouse.x = e.touches[0].clientX;
                        this.mouse.y = e.touches[0].clientY;
                    }
                });

                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (e.touches.length > 0) {
                        this.mouse.x = e.touches[0].clientX;
                        this.mouse.y = e.touches[0].clientY;
                    }
                });

                this.canvas.addEventListener('touchend', () => {
                    this.mouse.x = -1000;
                    this.mouse.y = -1000;
                });
            }

            setupSettingsToggle() {
                const toggle = document.getElementById('settingsToggle');
                const controls = document.getElementById('controls');
                
                if (toggle && controls) {
                    toggle.addEventListener('click', () => {
                        controls.classList.toggle('open');
                    });
                }
            }

            render() {
                // Clear canvas with background color
                this.ctx.fillStyle = this.settings.bgColor;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Debug: Log dot count
                if (this.dots.length === 0) {
                    console.log('No dots found! Regenerating...');
                    this.generateStippleGrid();
                }
                
                // Draw dots with soft edge fade
                this.dots.forEach((dot, i) => {
                    // Calculate fade based on distance from edges
                    const fadeZone = this.settings.fadeZone; // Pixels from edge where fade starts
                    const edgeDistances = [
                        dot.x, // Distance from left
                        this.canvas.width - dot.x, // Distance from right
                        dot.y, // Distance from top
                        this.canvas.height - dot.y // Distance from bottom
                    ];
                    
                    // Find the minimum distance to any edge
                    const minEdgeDistance = Math.min(...edgeDistances);
                    
                    // Calculate opacity based on edge proximity
                    let opacity = 1;
                    if (minEdgeDistance < fadeZone) {
                        opacity = Math.max(0, minEdgeDistance / fadeZone);
                        // Smooth easing for more natural fade
                        opacity = opacity * opacity * (3 - 2 * opacity); // Smoothstep function
                    }
                    
                    // Parse dot color and apply opacity
                    const color = this.settings.dotColor;
                    let r, g, b;
                    
                    if (color.startsWith('#')) {
                        // Convert hex to RGB
                        r = parseInt(color.slice(1, 3), 16);
                        g = parseInt(color.slice(3, 5), 16);
                        b = parseInt(color.slice(5, 7), 16);
                    } else {
                        // Default to gray if parsing fails
                        r = g = b = 204;
                    }
                    
                    this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                    this.ctx.beginPath();
                    this.ctx.arc(dot.x, dot.y, Math.max(dot.size, 0.5), 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }

            animate() {
                this.updateDots();
                this.render();
                requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize when page loads
        window.addEventListener('load', () => {
            new StippleSystem();
            
            // DON'T fade in the page here - wait for loading to complete
            // document.body.classList.add('loaded'); // REMOVED - will be set after loading
            
            // Add keyboard navigation with fade-out
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    document.body.classList.add('unloading');
                    setTimeout(() => {
                        window.location.href = 'portfolio/index.html';
                    }, 400);
                }
            });
            
            // Add fade-out to enter button click
            const enterButton = document.querySelector('.enter-button');
            if (enterButton) {
                enterButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    document.body.classList.add('unloading');
                    setTimeout(() => {
                        window.location.href = 'portfolio/index.html';
                    }, 400);
                });
            }
        });

        // Force reload when navigating back to prevent stuck unloading state
        window.addEventListener('pageshow', (e) => {
            if (e.persisted || document.body.classList.contains('unloading')) {
                window.location.reload();
            }
        });

        // Cleanup animation interval when page unloads
        window.addEventListener('beforeunload', () => {
            if (window.cogsAnimationInterval) {
                clearInterval(window.cogsAnimationInterval);
            }
            if (window.loaderAnimationInterval) {
                clearInterval(window.loaderAnimationInterval);
            }
        });
    </script>
</body>
</html> 
